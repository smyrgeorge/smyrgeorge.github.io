[{"content":"Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.\nFFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language. It acts as a bridge, allowing developers to leverage the strengths of different programming languages within a single project. FFI is essential for integrating diverse software libraries and for accessing hardware or operating system features not directly available in the host language. Implementing FFI involves defining bindings that specify how functions from one language can be called from another, including the necessary data type conversions.\nKotlin FFI As of the time these lines are being written, Kotlin/Native Interop (FFI) is still considered experimental. However, based on the experience I have had so far, it has seemed to me to be really stable. Take a look at the official documentation here: Interoperability with C | Kotlin Documentation\nCall a C function Let\u0026rsquo;s begin with a simple example. Assume we have a small C library:\n// This could be part of header file (e.g. lib.h) // The actual implementation of the C functions is not shown here. // Just a simple function that accepts a C string. void hello_1(char *msg); void hello_2(const char *msg); Here is the Kotlin part:\n// Import the C functions import mylib.hello_1 import mylib.hello_2 fun hello() { hello_1(\u0026#34;Hello from Kotlin\u0026#34;.cstr) hello_2(\u0026#34;Hello from Kotlin\u0026#34;.cstr) } More examples Here again, we have the C code:\nint fun_that_returns_int(void); // A LinkedList Node typedef struct Node { char *a_string_value; int an_int_value; struct Node *next; } Node; struct Node *get_a_node(); And the Kotlin:\nval r1: Int = fun_that_returns_int() // Here we can access the properties of a struct. val r2: CPointer\u0026lt;Node\u0026gt;? = get_a_node() val node: Node? = r2?.pointed if (node == null) { println(\u0026#34;null pointer returned\u0026#34;) } node?.let { println(it.a_string_value?.toKString() ?: \u0026#34;null value returned\u0026#34;) println(it.an_int_value) // Same as above (handle the pointer). it.next?.let { it1 -\u0026gt; // Handle the next node of the List. } } Pass a callback function to the C code The ability to \u0026ldquo;pass\u0026rdquo; functions to the C code is really helpful, especially if we want to create asynchronous flows. The basic idea is that we are going to call the foreign function from our code (in our case, the Kotlin code we will continue without blocking), and as soon as the result is ready, the foreign code will make the callback back to our code and provide the result data. In the case of sqlx4k, this was very important in order to create a non-blocking database driver.\nThe following examples are parts of sqlx4k, which wraps a database driver that is actually written in Rust. Although in this tutorial we are not going to see any Rust code, we will see a lot of C code. In reality, almost all the time we need to think about how the equivalent code would be in C. The reason is that almost all programming languages that provide FFI (Foreign Function Interface) offer bindings for C and C++.\nKotlin also provides interoperability with Swift and Objective-C (for more details, check the official documentation).\nSo, here is the C code.\n// Query result typedef struct Sqlx4kResult { int error; // error code char *error_message; void *tx; // transaction pointer int size; // result set size struct Sqlx4kRow *rows; // pointer to rows } Sqlx4kResult; // Raw pointer wrapper typedef struct Ptr { void *ptr; } Ptr; void sqlx4k_query(const char *sql, // Ignore for now. void *continuation, // Function pointer. void (*callback)(struct Ptr, struct Sqlx4kResult*)); In the following example, we make a call to the C function sqlx4k_query and we pass the following arguments:\nsql: the query that we need to execute in the database continuation: ignore for now (used for the async-io) callback: the function that the C code will call as soon as the result is ready. For now, let\u0026rsquo;s try to ignore the continuation and the async-io part of the code, let\u0026rsquo;s focus on the callback part.\n// It\u0026#39;s just an example, we do not return the actual fetched data. suspend fun query(sql: String) { suspendCoroutine { c: Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt; -\u0026gt; // Create a [StableRef] of the [Continuation] instance. // StableRef\u0026lt;Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt;\u0026gt; val ref = StableRef.create(c) val continuation: CPointer\u0026lt;out CPointed\u0026gt; = ref.asCPointer() // Call the actual C function. sqlx4k_query(sql, continuation, callback) } } // [callback] is the Kotlin function that we need to pass to the C code. val callback = staticCFunction\u0026lt;APtr, ACPointer, Unit\u0026gt; { c, r -\u0026gt; val ref = c.useContents { ptr }!! .asStableRef\u0026lt;Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt;\u0026gt;() ref.get().resume(r) ref.dispose() } typealias APtr = CValue\u0026lt;Ptr\u0026gt; typealias ACPointer = CPointer\u0026lt;Sqlx4kResult\u0026gt;? First of all, let\u0026rsquo;s take a look at the staticCFunction. In the Kotlin code, it is defined (as part of the kotlinx.cinterop package) like:\npublic external fun \u0026lt;P1, P2, R\u0026gt; staticCFunction( function: (P1, P2) -\u0026gt; R ): CPointer\u0026lt;CFunction\u0026lt;(P1, P2) -\u0026gt; R\u0026gt;\u0026gt; In our example, we use the staticCFunction to declare a function that takes two arguments, of type APtr and CPointer, and returns Unit. The C code can call this function as if it was a pure C function.\nHow to \u0026ldquo;not-block\u0026rdquo; In the previous example, we saw that we can pass a callback to the foreign code. In this section, we are going to explain how the \u0026ldquo;suspend\u0026rdquo; part works.\nKotlin offers the suspendCoroutine function.\n*According to the documentation: Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine. Continuation: Interface representing a continuation after a suspension point that returns a value of type T.\nIn other words, it is a way to suspend the execution flow, and the Continuation instance can provide us the way to continue the flow (in our case, after the data from the database are fetched).\nSo, as we saw:\n// The code will suspend here. suspendCoroutine { c: Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt; -\u0026gt; // Create a [StableRef] of the [Continuation] instance. // StableRef\u0026lt;Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt;\u0026gt; val ref = StableRef.create(c) val continuation: CPointer\u0026lt;out CPointed\u0026gt; = ref.asCPointer() // Call the actual C function. sqlx4k_query(sql, continuation, callback) } We need to pass the Continuation to the foreign code and then the foreign code will provide back to us (as a C raw pointer).\nThe way that Kotlin provides in order to pass references from \u0026ldquo;one world to another\u0026rdquo; is with StableRef:\n// Function pointer that will be passed to the foreign code. val callback = staticCFunction\u0026lt;APtr, ACPointer, Unit\u0026gt; { c, r -\u0026gt; // Cast raw pointer back to [StableRef] val ref = c.useContents { ptr }!! .asStableRef\u0026lt;Continuation\u0026lt;CPointer\u0026lt;Sqlx4kResult\u0026gt;?\u0026gt;\u0026gt;() // Call the resume, continue the suspended flow above. ref.get().resume(r) // Dispose (will free) the ref, // thus clear the reference to the continuation ref.dispose() } I believe the process is now a bit more understandable. We perform the reverse process:\nAccess the returned struct from the foreign code using useContents. Cast the raw pointer back to a StableRef. Resume the suspended flow. Dispose of the StableRef. Memory management Although until now everything seems very straightforward, there are some caveats. At every moment of this process, we need to keep in mind the memory management and how each one of the \u0026ldquo;worlds\u0026rdquo; allocates and deallocates memory. This is very crucial in order to avoid memory leaks.\nWhile I was developing the sqlx4k library, I created the following rule:\nEach one of the \u0026ldquo;worlds\u0026rdquo; (language) needs to manage its own memory.\nThis simply means that each language should deallocate the memory it allocated. In other words, we need to provide some more functions that will do this job for us. For instance, in my case, I created the following function that frees the allocated memory:\n// Function that deallocates the memory for a Sqlx4kResult struct. // Accepts a pointer to a struct [Sqlx4kResult]. void sqlx4k_free_result(struct Sqlx4kResult *ptr); In each language, this process could be a bit different. In my case, with Rust, I almost hacked the memory management by intentionally \u0026ldquo;leaking\u0026rdquo; memory and then calling the sqlx4k_free_result function from the Kotlin code in order to free the memory, thus avoiding a memory leak:\nfun \u0026lt;T\u0026gt; CPointer\u0026lt;Sqlx4kResult\u0026gt;?.use(f: (it: Sqlx4kResult) -\u0026gt; T): T { return try { // \u0026#34;Point\u0026#34; to the pointer this?.pointed?.let { f(it) } ?: error(\u0026#34;null pointer exception\u0026#34;) } finally { // Ensure that allways we will free the memory. sqlx4k_free_result(this) } } In the next part of this series, I will provide detailed examples on how I managed to do it (it wasn\u0026rsquo;t so difficult in the end).\nConclusion Although we need to be a bit more careful, especially with memory management\u0026mdash;even in the case of Kotlin and Rust, which are considered memory-safe languages\u0026mdash;I believe the whole process is not that difficult. Moreover, if you manage to \u0026ldquo;wire\u0026rdquo; the two languages for a given example (like wrapping a database driver), then doing it for a different task will become much easier, since you will have gained the knowledge and \u0026ldquo;invented\u0026rdquo; the necessary mechanics (or tricks, if you prefer).\nI think the benefits are numerous:\nContinue writing in Kotlin, as it is a modern and easy-to-learn language. Benefit from applications with a small memory footprint. Provide the Kotlin ecosystem with libraries that will help us develop more applications, especially on the backend. As always, take a look at the project\u0026rsquo;s repository on GitHub: GitHub - smyrgeorge/sqlx4k: A small non-blocking database driver written in Kotlin for the Native platform.\nAll contributions are welcome. Thank you very much.\nReferences Foreign function interface - Wikipedia Interoperability with C | Kotlin Documentation ","permalink":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/","summary":"Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.\nFFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language.","title":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)"},{"content":"Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:\nDependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn\u0026rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing \u0026ldquo;low-level\u0026rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native. In the subsequent parts, I\u0026rsquo;ll attempt to provide more detailed examples of how I managed to implement a simple SQL driver for PostgreSQL, using the sqlx (Rust) library.\nKtor I discovered that starting a new project with Ktor is very easy.\nKtor, developed by JetBrains, is a Kotlin-based framework optimized for asynchronous I/O operations, enabling efficient web and microservices development. Leveraging Kotlin\u0026rsquo;s coroutines, Ktor facilitates non-blocking I/O, which significantly enhances application scalability and performance. Its architecture supports seamless integration of async features, making it ideal for building responsive, high-performance applications with streamlined concurrency management.\nI began with the Ktor: Project Generator and created a sample project.\nThen, I only had to make a few changes to the build.gradle.kts file:\nplugins { kotlin(\u0026#34;multiplatform\u0026#34;) version \u0026#34;2.0.0\u0026#34; } repositories { mavenCentral() } group = \u0026#34;io.github.smyrgeorge\u0026#34; version = \u0026#34;0.1.0\u0026#34; val ktorVersion = \u0026#34;3.0.0-beta-1\u0026#34; val koinVersion = \u0026#34;3.5.6\u0026#34; kotlin { // Enable the according to your platform (you can enable them all): macosArm64 { binaries { executable() } } // linuxX64 { binaries { executable() } } // linuxX64 { binaries { executable() } } applyDefaultHierarchyTemplate() sourceSets { val nativeMain by getting { dependencies { // Ktor with CIO implementation(\u0026#34;io.ktor:ktor-server-cio:$ktorVersion\u0026#34;) // Koin (DI) implementation(\u0026#34;io.insert-koin:koin-core:$koinVersion\u0026#34;) // Database driver implementation(\u0026#34;io.github.smyrgeorge:sqlx4k:0.4.0\u0026#34;) } } } } And then I changed the main function to be like the default example:\nfun main() { embeddedServer(CIO, port = 8080) { routing { get (\u0026#34;/\u0026#34;) { call.respondText(\u0026#34;Hello, world!\u0026#34;) } } }.start(wait = true) } Then I build the project with:\n./gradlew build And finally, I started my sample service (ktor-native-sample):\n./build/bin/macosArm64/releaseExecutable/ktor-native-sample.kexe And I then I saw the following logs:\n[INFO] (io.ktor.server.Application): Application started in 0.0 seconds. [INFO] (io.ktor.server.Application): Responding at http://0.0.0.0:8080 As we can observe, the startup time was less than a second (a few milliseconds, I guess), which I find to be the interesting part. Additionally, I must mention that the memory usage was around ~5MB.\nA little bit of the background. So, the reality is that over the last couple of years, I have developed numerous projects using the Spring Boot stack (using Kotlin instead of Java). I believe we\u0026rsquo;re all aware of the notably slow startup times associated with JVM-based applications, not to mention the memory consumption (approximately ~50MB at startup).\nNaturally, those coming from other tech stacks (e.g., Rust, or something similar) might find this amusing. To a large extent, I almost agree with them. However, transitioning from one technology stack to another can sometimes be challenging.\nFor instance, I have been working for the same company for nearly 9 years now, and during this time, my team and I have implemented several projects and products using several technologies. In the back-end side, almost from the start, we chose the Spring Boot (Kotlin) stack. And I believe it has served us very well and also the code base has aged really well. Just to provide an example, we have a very large (and complex) insurance project, and we managed to migrate almost the entire project to Kotlin-async (coroutines) in just 5-6 months.\nDuring the migration period, we had to modify the parts of the code that accessed the database, the queues, and, of course, the entry points (e.g., the HTTP layer). Apart from that, in almost the rest of the codebase (service layer), we only needed to add the suspend keyword to indicate that a function is asynchronous (similar to async in Rust or JavaScript). It was a relatively easy process, considering the volume of code we had written up to that point and the complexity of the business model. Therefore, I consider this a significant success story.\nKotlin Native ecosystem So, I began to explore libraries that support multiplatform capabilities, specifically those that target to the native platform (e.g., to be compiled for linuxArm64). Very quickly, I realised that the ecosystem is still in a very early stage. Consequently, I contemplated developing some libraries myself. The most critical component for the type of applications my team has been building over the last few years is database access, specifically to PostgreSQL databases. However, as of now, there is no native driver available (or at least I couldn\u0026rsquo;t find one), prompting me to consider creating one. I soon realised that this task was not going to be easy. Additionally, during my research, I discovered some small projects that wrap the libpq (the official C database client) library using FFI.\nI also forgot to mention that in several side projects over the past few years, I have used the Rust programming language. Thus, I thought that perhaps I could try wrapping one of the Rust database drivers. I opted for sqlx because I had used it in the past and I believe it offers decent performance.\nSqlx4k So, I ended up creating sqlx4k (perhaps not the best name, but I wanted to convey that it\u0026rsquo;s a wrapper around the sqlx library). Sqlx4k is a minimal (and I believe it should remain minimal in the future) non-blocking database driver. Currently, it only supports PostgreSQL, but I plan to extend support to MySQL and eventually SQLite databases. By \u0026ldquo;minimal,\u0026rdquo; I mean it\u0026rsquo;s essentially a convenient wrapper around the Rust library, providing an idiomatic Kotlin API for database access.\nAs part of this article, I wanted to offer an introduction. In subsequent parts of this series, I will briefly describe how I managed to bridge the two different \u0026ldquo;worlds.\u0026rdquo;\nIf you found this introduction interesting and wish to experiment, you can add the dependency to your project and start exploring:\nimplementation(\u0026#34;io.github.smyrgeorge:sqlx4k:x.y.z\u0026#34;) You can find the latest published version here: Maven Central: io.github.smyrgeorge:sqlx4k\nHere is a small example:\nval pg = Postgres( host = \u0026#34;localhost\u0026#34;, port = 15432, username = \u0026#34;postgres\u0026#34;, password = \u0026#34;postgres\u0026#34;, database = \u0026#34;test\u0026#34;, maxConnections = 10 // set the max-pool-size here ) // Named parameters: pg.query(\u0026#34;drop table if exists :table;\u0026#34;, mapOf(\u0026#34;table\u0026#34; to \u0026#34;sqlx4k\u0026#34;)).getOrThrow() pg.fetchAll(\u0026#34;select * from :table;\u0026#34;, mapOf(\u0026#34;table\u0026#34; to \u0026#34;sqlx4k\u0026#34;)) { val id: Sqlx4k.Row.Column = get(\u0026#34;id\u0026#34;) Test(id = id.value.toInt()) } // Transactions: val tx1: Transaction = pg.begin().getOrThrow() tx1.query(\u0026#34;delete from sqlx4k;\u0026#34;).getOrThrow() tx1.fetchAll(\u0026#34;select * from sqlx4k;\u0026#34;) { println(debug()) } pg.fetchAll(\u0026#34;select * from sqlx4k;\u0026#34;) { println(debug()) } tx1.commit().getOrThrow() Also, take a look at the project\u0026rsquo;s repository on GitHub: GitHub - smyrgeorge/sqlx4k: A small non-blocking database driver written in Kotlin for the Native platform.\nAll contributions are welcome. Thank you for now.\nReferences Kotlin Programming Language Ktor: Build Asynchronous Servers and Clients in Kotlin | Ktor Framework GitHub - launchbadge/sqlx: ðŸ§° The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, and SQLite. ","permalink":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/","summary":"Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:\nDependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn\u0026rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing \u0026ldquo;low-level\u0026rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native.","title":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)"},{"content":"This is my-first-post, just checking that everything works correctly.\nfun main() { println(\u0026#34;Hello world!\u0026#34;) } ","permalink":"https://smyrgeorge.github.io/posts/my-first-post/","summary":"This is my-first-post, just checking that everything works correctly.\nfun main() { println(\u0026#34;Hello world!\u0026#34;) } ","title":"My First Post"}]