<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sqlx4k - Introduction to the Kotlin native and FFI (Part 2) | :: exploration and stuff ::</title>
<meta name=keywords content="dev,kotlin,ffi,rust,database-driver,postgres,mysql,sqlite"><meta name=description content="Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.
FFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language."><meta name=author content="Yorgos S."><link rel=canonical href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/><link crossorigin=anonymous href=/assets/css/stylesheet.c6c962257e0400eb9126b021c44264dc26b683382072bc5b0255db23207eaf8a.css integrity="sha256-xsliJX4EAOuRJrAhxEJk3Ca2gzggcrxbAlXbIyB+r4o=" rel="preload stylesheet" as=style><link rel=icon href=https://smyrgeorge.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://smyrgeorge.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://smyrgeorge.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://smyrgeorge.github.io/apple-touch-icon.png><link rel=mask-icon href=https://smyrgeorge.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-0Z3MG3WT5H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0Z3MG3WT5H")}</script><meta property="og:title" content="Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)"><meta property="og:description" content="Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.
FFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language."><meta property="og:type" content="article"><meta property="og:url" content="https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/"><meta property="og:image" content="https://smyrgeorge.github.io/images/16b3c7cfabbce3d7e297a63c597f29abb7049f3c.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-16T20:11:34+02:00"><meta property="article:modified_time" content="2024-07-16T20:11:34+02:00"><meta property="og:site_name" content=":: exploration and stuff ::"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://smyrgeorge.github.io/images/16b3c7cfabbce3d7e297a63c597f29abb7049f3c.png"><meta name=twitter:title content="Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)"><meta name=twitter:description content="Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.
FFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://smyrgeorge.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)","item":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)","name":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)","description":"Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.\nFFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language.","keywords":["dev","kotlin","ffi","rust","database-driver","postgres","mysql","sqlite"],"articleBody":"Introduction In the previous part of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.\nFFI Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language. It acts as a bridge, allowing developers to leverage the strengths of different programming languages within a single project. FFI is essential for integrating diverse software libraries and for accessing hardware or operating system features not directly available in the host language. Implementing FFI involves defining bindings that specify how functions from one language can be called from another, including the necessary data type conversions.\nKotlin FFI As of the time these lines are being written, Kotlin/Native Interop (FFI) is still considered experimental. However, based on the experience I have had so far, it has seemed to me to be really stable. Take a look at the official documentation here: Interoperability with C | Kotlin Documentation\nCall a C function Let’s begin with a simple example. Assume we have a small C library:\n// This could be part of header file (e.g. lib.h) // The actual implementation of the C functions is not shown here. // Just a simple function that accepts a C string. void hello_1(char *msg); void hello_2(const char *msg); Here is the Kotlin part:\n// Import the C functions import mylib.hello_1 import mylib.hello_2 fun hello() { hello_1(\"Hello from Kotlin\".cstr) hello_2(\"Hello from Kotlin\".cstr) } More examples Here again, we have the C code:\nint fun_that_returns_int(void); // A LinkedList Node typedef struct Node { char *a_string_value; int an_int_value; struct Node *next; } Node; struct Node *get_a_node(); And the Kotlin:\nval r1: Int = fun_that_returns_int() // Here we can access the properties of a struct. val r2: CPointer\u003cNode\u003e? = get_a_node() val node: Node? = r2?.pointed if (node == null) { println(\"null pointer returned\") } node?.let { println(it.a_string_value?.toKString() ?: \"null value returned\") println(it.an_int_value) // Same as above (handle the pointer). it.next?.let { it1 -\u003e // Handle the next node of the List. } } Pass a callback function to the C code The ability to “pass” functions to the C code is really helpful, especially if we want to create asynchronous flows. The basic idea is that we are going to call the foreign function from our code (in our case, the Kotlin code we will continue without blocking), and as soon as the result is ready, the foreign code will make the callback back to our code and provide the result data. In the case of sqlx4k, this was very important in order to create a non-blocking database driver.\nThe following examples are parts of sqlx4k, which wraps a database driver that is actually written in Rust. Although in this tutorial we are not going to see any Rust code, we will see a lot of C code. In reality, almost all the time we need to think about how the equivalent code would be in C. The reason is that almost all programming languages that provide FFI (Foreign Function Interface) offer bindings for C and C++.\nKotlin also provides interoperability with Swift and Objective-C (for more details, check the official documentation).\nSo, here is the C code.\n// Query result typedef struct Sqlx4kResult { int error; // error code char *error_message; void *tx; // transaction pointer int size; // result set size struct Sqlx4kRow *rows; // pointer to rows } Sqlx4kResult; // Raw pointer wrapper typedef struct Ptr { void *ptr; } Ptr; void sqlx4k_query(const char *sql, // Ignore for now. void *continuation, // Function pointer. void (*callback)(struct Ptr, struct Sqlx4kResult*)); In the following example, we make a call to the C function sqlx4k_query and we pass the following arguments:\nsql: the query that we need to execute in the database continuation: ignore for now (used for the async-io) callback: the function that the C code will call as soon as the result is ready. For now, let’s try to ignore the continuation and the async-io part of the code, let’s focus on the callback part.\n// It's just an example, we do not return the actual fetched data. suspend fun query(sql: String) { suspendCoroutine { c: Continuation\u003cCPointer\u003cSqlx4kResult\u003e?\u003e -\u003e // Create a [StableRef] of the [Continuation] instance. // StableRef","wordCount":"1611","inLanguage":"en","image":"https://smyrgeorge.github.io/images/16b3c7cfabbce3d7e297a63c597f29abb7049f3c.png","datePublished":"2024-07-16T20:11:34+02:00","dateModified":"2024-07-16T20:11:34+02:00","author":{"@type":"Person","name":"Yorgos S."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/"},"publisher":{"@type":"Organization","name":":: exploration and stuff ::","logo":{"@type":"ImageObject","url":"https://smyrgeorge.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://smyrgeorge.github.io/ accesskey=h title=":: exploration and stuff :: (Alt + H)"><img src=https://smyrgeorge.github.io/apple-touch-icon.png alt aria-label=logo height=35>:: exploration and stuff ::</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://smyrgeorge.github.io/archives title=archive><span>archive</span></a></li><li><a href=https://smyrgeorge.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://smyrgeorge.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://smyrgeorge.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://smyrgeorge.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://smyrgeorge.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Sqlx4k - Introduction to the Kotlin native and FFI (Part 2)</h1><div class=post-meta><span title='2024-07-16 20:11:34 +0200 CEST'>July 16, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1611 words&nbsp;·&nbsp;Yorgos S.&nbsp;|&nbsp;<a href=https://github.com/smyrgeorge/smyrgeorge.github.io-code/blob/main/content/posts/Sqlx4k%20-%20Introduction%20to%20the%20Kotlin%20native%20and%20FFI%20%28Part%202%29.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://smyrgeorge.github.io/images/16b3c7cfabbce3d7e297a63c597f29abb7049f3c.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#ffi>FFI</a></li><li><a href=#kotlin-ffi>Kotlin FFI</a><ul><li><a href=#call-a-c-function>Call a C function</a></li><li><a href=#more-examples>More examples</a></li><li><a href=#pass-a-callback-function-to-the-c-code>Pass a callback function to the C code</a></li></ul></li><li><a href=#how-to-not-block>How to &ldquo;not-block&rdquo;</a></li><li><a href=#memory-management>Memory management</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In the previous <a href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/>part</a> of this series, I attempted to explain the importance of the Kotlin FFI (Foreign Function Interface) compatibility layer. As I mentioned, I believe it is a very effective way (at least for now) to leverage other ecosystems (such as the Rust ecosystem) to bring functionality to the Kotlin/Native ecosystem, in which I see a great deal of potential.</p><h2 id=ffi>FFI<a hidden class=anchor aria-hidden=true href=#ffi>#</a></h2><p>Foreign Function Interface (FFI) is a programming feature that enables code written in one language to call and interact with code written in another language. It acts as a bridge, allowing developers to leverage the strengths of different programming languages within a single project. FFI is essential for integrating diverse software libraries and for accessing hardware or operating system features not directly available in the host language. Implementing FFI involves defining bindings that specify how functions from one language can be called from another, including the necessary data type conversions.</p><h2 id=kotlin-ffi>Kotlin FFI<a hidden class=anchor aria-hidden=true href=#kotlin-ffi>#</a></h2><p>As of the time these lines are being written, Kotlin/Native Interop (FFI) is still considered experimental. However, based on the experience I have had so far, it has seemed to me to be really stable. Take a look at the official documentation here: <a href=https://kotlinlang.org/docs/native-c-interop.html>Interoperability with C | Kotlin Documentation</a></p><h3 id=call-a-c-function>Call a C function<a hidden class=anchor aria-hidden=true href=#call-a-c-function>#</a></h3><p>Let&rsquo;s begin with a simple example. Assume we have a small C library:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// This could be part of header file (e.g. lib.h)
</span></span></span><span class=line><span class=cl><span class=c1>// The actual implementation of the C functions is not shown here.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Just a simple function that accepts a C string.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>hello_1</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hello_2</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>);</span>
</span></span></code></pre></div><p>Here is the Kotlin part:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Import the C functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>import</span> <span class=nn>mylib.hello_1</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>mylib.hello_2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>hello_1</span><span class=p>(</span><span class=s2>&#34;Hello from Kotlin&#34;</span><span class=p>.</span><span class=n>cstr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>hello_2</span><span class=p>(</span><span class=s2>&#34;Hello from Kotlin&#34;</span><span class=p>.</span><span class=n>cstr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=more-examples>More examples<a hidden class=anchor aria-hidden=true href=#more-examples>#</a></h3><p>Here again, we have the C code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun_that_returns_int</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A LinkedList Node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>a_string_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>an_int_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>Node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=o>*</span><span class=nf>get_a_node</span><span class=p>();</span>
</span></span></code></pre></div><p>And the Kotlin:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>r1</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=n>fun_that_returns_int</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Here we can access the properties of a struct.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>r2</span><span class=p>:</span> <span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Node</span><span class=p>&gt;?</span> <span class=p>=</span> <span class=n>get_a_node</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>node</span><span class=p>:</span> <span class=n>Node</span><span class=p>?</span> <span class=p>=</span> <span class=n>r2</span><span class=o>?.</span><span class=n>pointed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;null pointer returned&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>node</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>a_string_value</span><span class=o>?.</span><span class=n>toKString</span><span class=p>()</span> <span class=o>?:</span> <span class=s2>&#34;null value returned&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>an_int_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Same as above (handle the pointer).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>it</span><span class=p>.</span><span class=n>next</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span> <span class=n>it1</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle the next node of the List.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=pass-a-callback-function-to-the-c-code>Pass a callback function to the C code<a hidden class=anchor aria-hidden=true href=#pass-a-callback-function-to-the-c-code>#</a></h3><p>The ability to &ldquo;pass&rdquo; functions to the C code is really helpful, especially if we want to create asynchronous flows. The basic idea is that we are going to call the foreign function from our code (in our case, the Kotlin code we will continue without blocking), and as soon as the result is ready, the foreign code will make the callback back to our code and provide the result data. In the case of <code>sqlx4k</code>, this was very important in order to create a <code>non-blocking</code> database driver.</p><p>The following examples are parts of <code>sqlx4k</code>, which wraps a database driver that is actually written in <code>Rust</code>. Although in this tutorial we are not going to see any Rust code, we will see a lot of C code. In reality, almost all the time we need to think about how the equivalent code would be in C. The reason is that almost all programming languages that provide <code>FFI</code> (Foreign Function Interface) offer bindings for C and C++.</p><p>Kotlin also provides interoperability with Swift and Objective-C (for more details, check the official documentation).</p><p>So, here is the C code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Query result
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Sqlx4kResult</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>error</span><span class=p>;</span> <span class=c1>// error code
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=o>*</span><span class=n>error_message</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>tx</span><span class=p>;</span> <span class=c1>// transaction pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// result set size
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=n>Sqlx4kRow</span> <span class=o>*</span><span class=n>rows</span><span class=p>;</span> <span class=c1>// pointer to rows
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>Sqlx4kResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Raw pointer wrapper
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sqlx4k_query</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>sql</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=c1>// Ignore for now.
</span></span></span><span class=line><span class=cl><span class=c1></span>                  <span class=kt>void</span> <span class=o>*</span><span class=n>continuation</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=c1>// Function pointer.
</span></span></span><span class=line><span class=cl><span class=c1></span>                  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>callback</span><span class=p>)(</span><span class=k>struct</span> <span class=n>Ptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Sqlx4kResult</span><span class=o>*</span><span class=p>));</span>
</span></span></code></pre></div><p>In the following example, we make a call to the <code>C</code> function <code>sqlx4k_query</code> and we pass the following arguments:</p><ul><li><code>sql:</code> the query that we need to execute in the database</li><li><code>continuation:</code> ignore for now (used for the <code>async-io</code>)</li><li><code>callback:</code> the function that the C code will call as soon as the result is ready.</li></ul><p>For now, let&rsquo;s try to ignore the <code>continuation</code> and the <code>async-io</code> part of the code, let&rsquo;s focus on the callback part.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// It&#39;s just an example, we do not return the actual fetched data.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>query</span><span class=p>(</span><span class=n>sql</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>suspendCoroutine</span> <span class=p>{</span> <span class=n>c</span><span class=p>:</span> <span class=n>Continuation</span><span class=p>&lt;</span><span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;?&gt;</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Create a [StableRef] of the [Continuation] instance.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// StableRef&lt;Continuation&lt;CPointer&lt;Sqlx4kResult&gt;?&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>ref</span> <span class=p>=</span> <span class=nc>StableRef</span><span class=p>.</span><span class=n>create</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>continuation</span><span class=p>:</span> <span class=n>CPointer</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>CPointed</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>ref</span><span class=p>.</span><span class=n>asCPointer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Call the actual C function.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sqlx4k_query</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=n>continuation</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// [callback] is the Kotlin function that we need to pass to the C code.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>callback</span> <span class=p>=</span> <span class=n>staticCFunction</span><span class=p>&lt;</span><span class=n>APtr</span><span class=p>,</span> <span class=n>ACPointer</span><span class=p>,</span> <span class=n>Unit</span><span class=p>&gt;</span> <span class=p>{</span> <span class=n>c</span><span class=p>,</span> <span class=n>r</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>ref</span> <span class=p>=</span> <span class=n>c</span><span class=p>.</span><span class=n>useContents</span> <span class=p>{</span> <span class=n>ptr</span> <span class=p>}</span><span class=o>!!</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>asStableRef</span><span class=p>&lt;</span><span class=n>Continuation</span><span class=p>&lt;</span><span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;?&gt;&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=n>ref</span><span class=p>.</span><span class=k>get</span><span class=p>().</span><span class=n>resume</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ref</span><span class=p>.</span><span class=n>dispose</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typealias</span> <span class=n>APtr</span> <span class=p>=</span> <span class=n>CValue</span><span class=p>&lt;</span><span class=n>Ptr</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>typealias</span> <span class=n>ACPointer</span> <span class=p>=</span> <span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;?</span>
</span></span></code></pre></div><p>First of all, let&rsquo;s take a look at the <a href=https://kotlinlang.org/docs/native-c-interop.html#callbacks><code>staticCFunction</code></a>.
In the Kotlin code, it is defined (as part of the <code>kotlinx.cinterop</code> package) like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>external</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>P1</span><span class=p>,</span> <span class=nc>P2</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>staticCFunction</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>function</span><span class=p>:</span> <span class=p>(</span><span class=n>P1</span><span class=p>,</span> <span class=n>P2</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>CPointer</span><span class=p>&lt;</span><span class=n>CFunction</span><span class=p>&lt;(</span><span class=n>P1</span><span class=p>,</span> <span class=n>P2</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>In our example, we use the <a href=https://kotlinlang.org/docs/native-c-interop.html#callbacks><code>staticCFunction</code></a> to declare a function that takes two arguments, of type <code>APtr</code> and <code>CPointer</code>, and returns <code>Unit</code>. The C code can call this function as if it was a pure C function.</p><h2 id=how-to-not-block>How to &ldquo;not-block&rdquo;<a hidden class=anchor aria-hidden=true href=#how-to-not-block>#</a></h2><p>In the previous example, we saw that we can pass a callback to the foreign code. In this section, we are going to explain how the &ldquo;suspend&rdquo; part works.</p><p>Kotlin offers the <a href=https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.coroutines/suspend-coroutine.html><code>suspendCoroutine</code></a> function.</p><p>*According to the documentation:
Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine. <code>Continuation</code>: Interface representing a continuation after a suspension point that returns a value of type T.</p><p>In other words, it is a way to <code>suspend</code> the execution flow, and the <a href><code>Continuation</code></a> instance can provide us the way to continue the flow (in our case, after the data from the database are fetched).</p><p>So, as we saw:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// The code will suspend here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>suspendCoroutine</span> <span class=p>{</span> <span class=n>c</span><span class=p>:</span> <span class=n>Continuation</span><span class=p>&lt;</span><span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;?&gt;</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a [StableRef] of the [Continuation] instance.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// StableRef&lt;Continuation&lt;CPointer&lt;Sqlx4kResult&gt;?&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>ref</span> <span class=p>=</span> <span class=nc>StableRef</span><span class=p>.</span><span class=n>create</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>continuation</span><span class=p>:</span> <span class=n>CPointer</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>CPointed</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>ref</span><span class=p>.</span><span class=n>asCPointer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Call the actual C function.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sqlx4k_query</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=n>continuation</span><span class=p>,</span> <span class=n>callback</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We need to pass the <a href=https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.coroutines/-continuation/><code>Continuation</code></a> to the foreign code and then the foreign code will provide back to us (as a C raw pointer).</p><p>The way that <code>Kotlin</code> provides in order to pass references from &ldquo;one world to another&rdquo; is with <a href=https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/-stable-ref/><code>StableRef</code></a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Function pointer that will be passed to the foreign code.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>callback</span> <span class=p>=</span> <span class=n>staticCFunction</span><span class=p>&lt;</span><span class=n>APtr</span><span class=p>,</span> <span class=n>ACPointer</span><span class=p>,</span> <span class=n>Unit</span><span class=p>&gt;</span> <span class=p>{</span> <span class=n>c</span><span class=p>,</span> <span class=n>r</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Cast raw pointer back to [StableRef]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>ref</span> <span class=p>=</span> <span class=n>c</span><span class=p>.</span><span class=n>useContents</span> <span class=p>{</span> <span class=n>ptr</span> <span class=p>}</span><span class=o>!!</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>asStableRef</span><span class=p>&lt;</span><span class=n>Continuation</span><span class=p>&lt;</span><span class=n>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;?&gt;&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Call the resume, continue the suspended flow above.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ref</span><span class=p>.</span><span class=k>get</span><span class=p>().</span><span class=n>resume</span><span class=p>(</span><span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Dispose (will free) the ref,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// thus clear the reference to the continuation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ref</span><span class=p>.</span><span class=n>dispose</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I believe the process is now a bit more understandable. We perform the reverse process:</p><ul><li>Access the returned struct from the foreign code using <code>useContents</code>.</li><li>Cast the raw pointer back to a <code>StableRef</code>.</li><li><code>Resume</code> the suspended flow.</li><li><code>Dispose</code> of the <code>StableRef</code>.</li></ul><h2 id=memory-management>Memory management<a hidden class=anchor aria-hidden=true href=#memory-management>#</a></h2><p>Although until now everything seems very straightforward, there are some caveats. At every moment of this process, we need to keep in mind the memory management and how each one of the &ldquo;worlds&rdquo; allocates and deallocates memory. This is very crucial in order to avoid memory leaks.</p><p>While I was developing the <code>sqlx4k</code> library, I created the following rule:</p><blockquote><p><strong>Each one of the &ldquo;worlds&rdquo; (language) needs to manage its own memory.</strong></p></blockquote><p><img loading=lazy src=/images/16b3c7cfabbce3d7e297a63c597f29abb7049f3c.png alt=sqlx4k></p><p>This simply means that each language should deallocate the memory it allocated. In other words, we need to provide some more functions that will do this job for us. For instance, in my case, I created the following function that frees the allocated memory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Function that deallocates the memory for a Sqlx4kResult struct.
</span></span></span><span class=line><span class=cl><span class=c1>// Accepts a pointer to a struct [Sqlx4kResult].
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>sqlx4k_free_result</span><span class=p>(</span><span class=k>struct</span> <span class=n>Sqlx4kResult</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span></code></pre></div><p>In each language, this process could be a bit different. In my case, with Rust, I almost hacked the memory management by intentionally &ldquo;leaking&rdquo; memory and then calling the <code>sqlx4k_free_result</code> function from the Kotlin code in order to free the memory, thus avoiding a memory leak:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>CPointer</span><span class=p>&lt;</span><span class=n>Sqlx4kResult</span><span class=p>&gt;</span><span class=o>?.</span><span class=n>use</span><span class=p>(</span><span class=n>f</span><span class=p>:</span> <span class=p>(</span><span class=k>it</span><span class=p>:</span> <span class=n>Sqlx4kResult</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>T</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// &#34;Point&#34; to the pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>?.</span><span class=n>pointed</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span> <span class=n>f</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=o>?:</span> <span class=n>error</span><span class=p>(</span><span class=s2>&#34;null pointer exception&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Ensure that allways we will free the memory.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sqlx4k_free_result</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the next part of this series, I will provide detailed examples on how I managed to do it (it wasn&rsquo;t so difficult in the end).</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Although we need to be a bit more careful, especially with memory management&mdash;even in the case of Kotlin and Rust, which are considered memory-safe languages&mdash;I believe the whole process is not that difficult. Moreover, if you manage to &ldquo;wire&rdquo; the two languages for a given example (like wrapping a database driver), then doing it for a different task will become much easier, since you will have gained the knowledge and &ldquo;invented&rdquo; the necessary mechanics (or tricks, if you prefer).</p><p>I think the benefits are numerous:</p><ul><li>Continue writing in Kotlin, as it is a modern and easy-to-learn language.</li><li>Benefit from applications with a small memory footprint.</li><li>Provide the Kotlin ecosystem with libraries that will help us develop more applications, especially on the backend.</li></ul><p>As always, take a look at the project&rsquo;s repository on GitHub:
<a href=https://github.com/smyrgeorge/sqlx4k>GitHub - smyrgeorge/sqlx4k: A small non-blocking database driver written in Kotlin for the Native platform.</a></p><p>All contributions are welcome. Thank you very much.</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Foreign_function_interface>Foreign function interface - Wikipedia</a></li><li><a href=https://kotlinlang.org/docs/native-c-interop.html>Interoperability with C | Kotlin Documentation</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://smyrgeorge.github.io/tags/dev/>Dev</a></li><li><a href=https://smyrgeorge.github.io/tags/kotlin/>Kotlin</a></li><li><a href=https://smyrgeorge.github.io/tags/ffi/>Ffi</a></li><li><a href=https://smyrgeorge.github.io/tags/rust/>Rust</a></li><li><a href=https://smyrgeorge.github.io/tags/database-driver/>Database-Driver</a></li><li><a href=https://smyrgeorge.github.io/tags/postgres/>Postgres</a></li><li><a href=https://smyrgeorge.github.io/tags/mysql/>Mysql</a></li><li><a href=https://smyrgeorge.github.io/tags/sqlite/>Sqlite</a></li></ul></footer><hr style=margin-top:56px><div id=disqus_thread style=margin-top:20px></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://smyrgeorge.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://smyrgeorge.github.io/>:: exploration and stuff ::</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>