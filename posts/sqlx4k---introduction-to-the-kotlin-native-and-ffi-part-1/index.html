<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sqlx4k - Introduction to the Kotlin native and FFI (Part 1) | :: exploration and stuff ::</title>
<meta name=keywords content="dev,kotlin,ffi,rust,database-driver,postgres,mysql,sqlite"><meta name=description content="Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:
Dependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn&rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing &ldquo;low-level&rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native."><meta name=author content="Yorgos S."><link rel=canonical href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/><link crossorigin=anonymous href=/assets/css/stylesheet.c6c962257e0400eb9126b021c44264dc26b683382072bc5b0255db23207eaf8a.css integrity="sha256-xsliJX4EAOuRJrAhxEJk3Ca2gzggcrxbAlXbIyB+r4o=" rel="preload stylesheet" as=style><link rel=icon href=https://smyrgeorge.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://smyrgeorge.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://smyrgeorge.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://smyrgeorge.github.io/apple-touch-icon.png><link rel=mask-icon href=https://smyrgeorge.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-0Z3MG3WT5H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0Z3MG3WT5H")}</script><meta property="og:title" content="Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)"><meta property="og:description" content="Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:
Dependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn&rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing &ldquo;low-level&rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native."><meta property="og:type" content="article"><meta property="og:url" content="https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/"><meta property="og:image" content="https://smyrgeorge.github.io/images/7a68c51ab98060e8e5b4cbdbae694e450abfb270.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-08T13:26:07+02:00"><meta property="article:modified_time" content="2024-07-08T13:26:07+02:00"><meta property="og:site_name" content=":: exploration and stuff ::"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://smyrgeorge.github.io/images/7a68c51ab98060e8e5b4cbdbae694e450abfb270.png"><meta name=twitter:title content="Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)"><meta name=twitter:description content="Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:
Dependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn&rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing &ldquo;low-level&rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://smyrgeorge.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)","item":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)","name":"Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)","description":"Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:\nDependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn\u0026rsquo;t a priority for now) In this first article of the series, I aim to describe how I ended up writing \u0026ldquo;low-level\u0026rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native.","keywords":["dev","kotlin","ffi","rust","database-driver","postgres","mysql","sqlite"],"articleBody":"Introduction Recently, I began experimenting with the Kotlin Native platform. I initiated a new repository and attempted to create a simple project utilizing the ktor libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:\nDependency injection HTTP server Database access (PostgreSQL) Additionally, RabbitMQ support (though it isn’t a priority for now) In this first article of the series, I aim to describe how I ended up writing “low-level” code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native. In the subsequent parts, I’ll attempt to provide more detailed examples of how I managed to implement a simple SQL driver for PostgreSQL, using the sqlx (Rust) library.\nKtor I discovered that starting a new project with Ktor is very easy.\nKtor, developed by JetBrains, is a Kotlin-based framework optimized for asynchronous I/O operations, enabling efficient web and microservices development. Leveraging Kotlin’s coroutines, Ktor facilitates non-blocking I/O, which significantly enhances application scalability and performance. Its architecture supports seamless integration of async features, making it ideal for building responsive, high-performance applications with streamlined concurrency management.\nI began with the Ktor: Project Generator and created a sample project.\nThen, I only had to make a few changes to the build.gradle.kts file:\nplugins { kotlin(\"multiplatform\") version \"2.0.0\" } repositories { mavenCentral() } group = \"io.github.smyrgeorge\" version = \"0.1.0\" val ktorVersion = \"3.0.0-beta-1\" val koinVersion = \"3.5.6\" kotlin { // Enable the according to your platform (you can enable them all): macosArm64 { binaries { executable() } } // linuxX64 { binaries { executable() } } // linuxX64 { binaries { executable() } } applyDefaultHierarchyTemplate() sourceSets { val nativeMain by getting { dependencies { // Ktor with CIO implementation(\"io.ktor:ktor-server-cio:$ktorVersion\") // Koin (DI) implementation(\"io.insert-koin:koin-core:$koinVersion\") // Database driver implementation(\"io.github.smyrgeorge:sqlx4k:0.4.0\") } } } } And then I changed the main function to be like the default example:\nfun main() { embeddedServer(CIO, port = 8080) { routing { get (\"/\") { call.respondText(\"Hello, world!\") } } }.start(wait = true) } Then I build the project with:\n./gradlew build And finally, I started my sample service (ktor-native-sample):\n./build/bin/macosArm64/releaseExecutable/ktor-native-sample.kexe And I then I saw the following logs:\n[INFO] (io.ktor.server.Application): Application started in 0.0 seconds. [INFO] (io.ktor.server.Application): Responding at http://0.0.0.0:8080 As we can observe, the startup time was less than a second (a few milliseconds, I guess), which I find to be the interesting part. Additionally, I must mention that the memory usage was around ~5MB.\nA little bit of the background. So, the reality is that over the last couple of years, I have developed numerous projects using the Spring Boot stack (using Kotlin instead of Java). I believe we’re all aware of the notably slow startup times associated with JVM-based applications, not to mention the memory consumption (approximately ~50MB at startup).\nNaturally, those coming from other tech stacks (e.g., Rust, or something similar) might find this amusing. To a large extent, I almost agree with them. However, transitioning from one technology stack to another can sometimes be challenging.\nFor instance, I have been working for the same company for nearly 9 years now, and during this time, my team and I have implemented several projects and products using several technologies. In the back-end side, almost from the start, we chose the Spring Boot (Kotlin) stack. And I believe it has served us very well and also the code base has aged really well. Just to provide an example, we have a very large (and complex) insurance project, and we managed to migrate almost the entire project to Kotlin-async (coroutines) in just 5-6 months.\nDuring the migration period, we had to modify the parts of the code that accessed the database, the queues, and, of course, the entry points (e.g., the HTTP layer). Apart from that, in almost the rest of the codebase (service layer), we only needed to add the suspend keyword to indicate that a function is asynchronous (similar to async in Rust or JavaScript). It was a relatively easy process, considering the volume of code we had written up to that point and the complexity of the business model. Therefore, I consider this a significant success story.\nKotlin Native ecosystem So, I began to explore libraries that support multiplatform capabilities, specifically those that target to the native platform (e.g., to be compiled for linuxArm64). Very quickly, I realised that the ecosystem is still in a very early stage. Consequently, I contemplated developing some libraries myself. The most critical component for the type of applications my team has been building over the last few years is database access, specifically to PostgreSQL databases. However, as of now, there is no native driver available (or at least I couldn’t find one), prompting me to consider creating one. I soon realised that this task was not going to be easy. Additionally, during my research, I discovered some small projects that wrap the libpq (the official C database client) library using FFI.\nI also forgot to mention that in several side projects over the past few years, I have used the Rust programming language. Thus, I thought that perhaps I could try wrapping one of the Rust database drivers. I opted for sqlx because I had used it in the past and I believe it offers decent performance.\nSqlx4k So, I ended up creating sqlx4k (perhaps not the best name, but I wanted to convey that it’s a wrapper around the sqlx library). Sqlx4k is a minimal (and I believe it should remain minimal in the future) non-blocking database driver. Currently, it only supports PostgreSQL, but I plan to extend support to MySQL and eventually SQLite databases. By “minimal,” I mean it’s essentially a convenient wrapper around the Rust library, providing an idiomatic Kotlin API for database access.\nAs part of this article, I wanted to offer an introduction. In subsequent parts of this series, I will briefly describe how I managed to bridge the two different “worlds.”\nIf you found this introduction interesting and wish to experiment, you can add the dependency to your project and start exploring:\nimplementation(\"io.github.smyrgeorge:sqlx4k:x.y.z\") You can find the latest published version here: Maven Central: io.github.smyrgeorge:sqlx4k\nHere is a small example:\nval pg = Postgres( host = \"localhost\", port = 15432, username = \"postgres\", password = \"postgres\", database = \"test\", maxConnections = 10 // set the max-pool-size here ) // Named parameters: pg.query(\"drop table if exists :table;\", mapOf(\"table\" to \"sqlx4k\")).getOrThrow() pg.fetchAll(\"select * from :table;\", mapOf(\"table\" to \"sqlx4k\")) { val id: Sqlx4k.Row.Column = get(\"id\") Test(id = id.value.toInt()) } // Transactions: val tx1: Transaction = pg.begin().getOrThrow() tx1.query(\"delete from sqlx4k;\").getOrThrow() tx1.fetchAll(\"select * from sqlx4k;\") { println(debug()) } pg.fetchAll(\"select * from sqlx4k;\") { println(debug()) } tx1.commit().getOrThrow() Also, take a look at the project’s repository on GitHub: GitHub - smyrgeorge/sqlx4k: A small non-blocking database driver written in Kotlin for the Native platform.\nAll contributions are welcome. Thank you for now.\nReferences Kotlin Programming Language Ktor: Build Asynchronous Servers and Clients in Kotlin | Ktor Framework GitHub - launchbadge/sqlx: 🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, and SQLite. ","wordCount":"1200","inLanguage":"en","image":"https://smyrgeorge.github.io/images/7a68c51ab98060e8e5b4cbdbae694e450abfb270.png","datePublished":"2024-07-08T13:26:07+02:00","dateModified":"2024-07-08T13:26:07+02:00","author":{"@type":"Person","name":"Yorgos S."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-1/"},"publisher":{"@type":"Organization","name":":: exploration and stuff ::","logo":{"@type":"ImageObject","url":"https://smyrgeorge.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://smyrgeorge.github.io/ accesskey=h title=":: exploration and stuff :: (Alt + H)"><img src=https://smyrgeorge.github.io/apple-touch-icon.png alt aria-label=logo height=35>:: exploration and stuff ::</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://smyrgeorge.github.io/archives title=archive><span>archive</span></a></li><li><a href=https://smyrgeorge.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://smyrgeorge.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://smyrgeorge.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://smyrgeorge.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://smyrgeorge.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Sqlx4k - Introduction to the Kotlin native and FFI (Part 1)</h1><div class=post-meta><span title='2024-07-08 13:26:07 +0200 CEST'>July 8, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1200 words&nbsp;·&nbsp;Yorgos S.&nbsp;|&nbsp;<a href=https://github.com/smyrgeorge/smyrgeorge.github.io-code/blob/main/content/posts/Sqlx4k%20-%20Introduction%20to%20the%20Kotlin%20native%20and%20FFI%20%28Part%201%29.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://smyrgeorge.github.io/images/7a68c51ab98060e8e5b4cbdbae694e450abfb270.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#ktor>Ktor</a></li><li><a href=#a-little-bit-of-the-background>A little bit of the background.</a></li><li><a href=#kotlin-native-ecosystem>Kotlin Native ecosystem</a></li><li><a href=#sqlx4k>Sqlx4k</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Recently, I began experimenting with the <code>Kotlin Native platform</code>. I initiated a new repository and attempted to create a simple project utilizing the <code>ktor</code> libraries. The purpose of the project was to recreate a small service that integrates some basic libraries and compile it to a native target (macosArm64 in my case). The service aimed to offer support for:</p><ul><li>Dependency injection</li><li>HTTP server</li><li>Database access (PostgreSQL)</li><li>Additionally, RabbitMQ support (though it isn&rsquo;t a priority for now)</li></ul><p>In this first article of the series, I aim to describe how I ended up writing &ldquo;low-level&rdquo; code (FFI between Kotlin and Rust) and also to highlight the importance of native compatibility in Kotlin Native. In the subsequent parts, I&rsquo;ll attempt to provide more detailed examples of how I managed to implement a simple SQL driver for PostgreSQL, using the sqlx (Rust) library.</p><h2 id=ktor>Ktor<a hidden class=anchor aria-hidden=true href=#ktor>#</a></h2><p>I discovered that starting a new project with Ktor is very easy.</p><p>Ktor, developed by JetBrains, is a Kotlin-based framework optimized for asynchronous I/O operations, enabling efficient web and microservices development. Leveraging Kotlin&rsquo;s coroutines, Ktor facilitates non-blocking I/O, which significantly enhances application scalability and performance. Its architecture supports seamless integration of async features, making it ideal for building responsive, high-performance applications with streamlined concurrency management.</p><p>I began with the <a href=https://start.ktor.io/settings>Ktor: Project Generator</a> and created a sample project.</p><p>Then, I only had to make a few changes to the <code>build.gradle.kts</code> file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>plugins</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>kotlin</span><span class=p>(</span><span class=s2>&#34;multiplatform&#34;</span><span class=p>)</span> <span class=n>version</span> <span class=s2>&#34;2.0.0&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>repositories</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mavenCentral</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>group</span> <span class=p>=</span> <span class=s2>&#34;io.github.smyrgeorge&#34;</span>
</span></span><span class=line><span class=cl><span class=n>version</span> <span class=p>=</span> <span class=s2>&#34;0.1.0&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>ktorVersion</span> <span class=p>=</span> <span class=s2>&#34;3.0.0-beta-1&#34;</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>koinVersion</span> <span class=p>=</span> <span class=s2>&#34;3.5.6&#34;</span>
</span></span><span class=line><span class=cl><span class=n>kotlin</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Enable the according to your platform (you can enable them all):
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>macosArm64</span> <span class=p>{</span> <span class=n>binaries</span> <span class=p>{</span> <span class=n>executable</span><span class=p>()</span> <span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// linuxX64 { binaries { executable() } }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// linuxX64 { binaries { executable() } }
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>applyDefaultHierarchyTemplate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>sourceSets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>nativeMain</span> <span class=k>by</span> <span class=n>getting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dependencies</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Ktor with CIO
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>implementation</span><span class=p>(</span><span class=s2>&#34;io.ktor:ktor-server-cio:</span><span class=si>$ktorVersion</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Koin (DI)
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>implementation</span><span class=p>(</span><span class=s2>&#34;io.insert-koin:koin-core:</span><span class=si>$koinVersion</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Database driver
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>implementation</span><span class=p>(</span><span class=s2>&#34;io.github.smyrgeorge:sqlx4k:0.4.0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And then I changed the <strong>main</strong> function to be like the default example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>embeddedServer</span><span class=p>(</span><span class=n>CIO</span><span class=p>,</span> <span class=n>port</span> <span class=p>=</span> <span class=m>8080</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>routing</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>get</span> <span class=p>(</span><span class=s2>&#34;/&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>call</span><span class=p>.</span><span class=n>respondText</span><span class=p>(</span><span class=s2>&#34;Hello, world!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>start</span><span class=p>(</span><span class=n>wait</span> <span class=p>=</span> <span class=k>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Then I build the project with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./gradlew build
</span></span></code></pre></div><p>And finally, I started my sample service (ktor-native-sample):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>./build/bin/macosArm64/releaseExecutable/ktor-native-sample.kexe
</span></span></code></pre></div><p>And I then I saw the following logs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[INFO] (io.ktor.server.Application): Application started in 0.0 seconds.
</span></span><span class=line><span class=cl>[INFO] (io.ktor.server.Application): Responding at http://0.0.0.0:8080
</span></span></code></pre></div><p>As we can observe, the startup time was less than a second (a few milliseconds, I guess), which I find to be the interesting part. Additionally, I must mention that the memory usage was around <code>~5MB</code>.</p><h2 id=a-little-bit-of-the-background>A little bit of the background.<a hidden class=anchor aria-hidden=true href=#a-little-bit-of-the-background>#</a></h2><p>So, the reality is that over the last couple of years, I have developed numerous projects using the Spring Boot stack (using Kotlin instead of Java). I believe we&rsquo;re all aware of the notably slow startup times associated with JVM-based applications, not to mention the memory consumption (approximately ~50MB at startup).</p><p>Naturally, those coming from other tech stacks (e.g., Rust, or something similar) might find this amusing. To a large extent, I almost agree with them. However, transitioning from one technology stack to another can sometimes be challenging.</p><p>For instance, I have been working for the same company for nearly 9 years now, and during this time, my team and I have implemented several projects and products using several technologies. In the back-end side, almost from the start, we chose the Spring Boot (Kotlin) stack. And I believe it has served us very well and also the code base has aged really well. Just to provide an example, we have a very large (and complex) insurance project, and we managed to migrate almost the entire project to Kotlin-async (coroutines) in just 5-6 months.</p><p>During the migration period, we had to modify the parts of the code that accessed the database, the queues, and, of course, the entry points (e.g., the HTTP layer). Apart from that, in almost the rest of the codebase (service layer), we only needed to add the <strong>suspend</strong> keyword to indicate that a function is asynchronous (similar to async in Rust or JavaScript). It was a relatively easy process, considering the volume of code we had written up to that point and the complexity of the business model. Therefore, I consider this a significant success story.</p><h2 id=kotlin-native-ecosystem>Kotlin Native ecosystem<a hidden class=anchor aria-hidden=true href=#kotlin-native-ecosystem>#</a></h2><p>So, I began to explore libraries that support multiplatform capabilities, specifically those that target to the native platform (e.g., to be compiled for linuxArm64). Very quickly, I realised that the ecosystem is still in a very early stage. Consequently, I contemplated developing some libraries myself. The most critical component for the type of applications my team has been building over the last few years is database access, specifically to PostgreSQL databases. However, as of now, there is no native driver available (or at least I couldn&rsquo;t find one), prompting me to consider creating one. I soon realised that this task was not going to be easy. Additionally, during my research, I discovered some small projects that wrap the <strong>libpq</strong> (the official <strong>C</strong> database client) library using FFI.</p><p>I also forgot to mention that in several side projects over the past few years, I have used the Rust programming language. Thus, I thought that perhaps I could try wrapping one of the Rust database drivers. I opted for <strong>sqlx</strong> because I had used it in the past and I believe it offers decent performance.</p><h2 id=sqlx4k>Sqlx4k<a hidden class=anchor aria-hidden=true href=#sqlx4k>#</a></h2><p>So, I ended up creating <strong>sqlx4k</strong> (perhaps not the best name, but I wanted to convey that it&rsquo;s a wrapper around the <strong>sqlx</strong> library). Sqlx4k is a minimal (and I believe it should remain minimal in the future) non-blocking database driver. Currently, it only supports PostgreSQL, but I plan to extend support to MySQL and eventually SQLite databases. By &ldquo;minimal,&rdquo; I mean it&rsquo;s essentially a convenient wrapper around the Rust library, providing an idiomatic Kotlin API for database access.</p><p><img loading=lazy src=/images/7a68c51ab98060e8e5b4cbdbae694e450abfb270.png alt=sqlx4k></p><p>As part of this article, I wanted to offer an introduction. In subsequent parts of this series, I will briefly describe how I managed to bridge the two different &ldquo;worlds.&rdquo;</p><p>If you found this introduction interesting and wish to experiment, you can add the dependency to your project and start exploring:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>implementation</span><span class=p>(</span><span class=s2>&#34;io.github.smyrgeorge:sqlx4k:x.y.z&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>You can find the latest published version here: <a href=https://central.sonatype.com/artifact/io.github.smyrgeorge/sqlx4k>Maven Central: io.github.smyrgeorge:sqlx4k</a></p><p>Here is a small example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>pg</span> <span class=p>=</span> <span class=n>Postgres</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>host</span> <span class=p>=</span> <span class=s2>&#34;localhost&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>port</span> <span class=p>=</span> <span class=m>15432</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>username</span> <span class=p>=</span> <span class=s2>&#34;postgres&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>password</span> <span class=p>=</span> <span class=s2>&#34;postgres&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>database</span> <span class=p>=</span> <span class=s2>&#34;test&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>maxConnections</span> <span class=p>=</span> <span class=m>10</span> <span class=c1>// set the max-pool-size here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Named parameters:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pg</span><span class=p>.</span><span class=n>query</span><span class=p>(</span><span class=s2>&#34;drop table if exists :table;&#34;</span><span class=p>,</span> <span class=n>mapOf</span><span class=p>(</span><span class=s2>&#34;table&#34;</span> <span class=n>to</span> <span class=s2>&#34;sqlx4k&#34;</span><span class=p>)).</span><span class=n>getOrThrow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pg</span><span class=p>.</span><span class=n>fetchAll</span><span class=p>(</span><span class=s2>&#34;select * from :table;&#34;</span><span class=p>,</span> <span class=n>mapOf</span><span class=p>(</span><span class=s2>&#34;table&#34;</span> <span class=n>to</span> <span class=s2>&#34;sqlx4k&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>id</span><span class=p>:</span> <span class=n>Sqlx4k</span><span class=p>.</span><span class=nc>Row</span><span class=p>.</span><span class=n>Column</span> <span class=p>=</span> <span class=k>get</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>Test</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>id</span><span class=p>.</span><span class=k>value</span><span class=p>.</span><span class=n>toInt</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Transactions:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>tx1</span><span class=p>:</span> <span class=n>Transaction</span> <span class=p>=</span> <span class=n>pg</span><span class=p>.</span><span class=n>begin</span><span class=p>().</span><span class=n>getOrThrow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>tx1</span><span class=p>.</span><span class=n>query</span><span class=p>(</span><span class=s2>&#34;delete from sqlx4k;&#34;</span><span class=p>).</span><span class=n>getOrThrow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>tx1</span><span class=p>.</span><span class=n>fetchAll</span><span class=p>(</span><span class=s2>&#34;select * from sqlx4k;&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>debug</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pg</span><span class=p>.</span><span class=n>fetchAll</span><span class=p>(</span><span class=s2>&#34;select * from sqlx4k;&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>debug</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>tx1</span><span class=p>.</span><span class=n>commit</span><span class=p>().</span><span class=n>getOrThrow</span><span class=p>()</span>
</span></span></code></pre></div><p>Also, take a look at the project&rsquo;s repository on GitHub:
<a href=https://github.com/smyrgeorge/sqlx4k>GitHub - smyrgeorge/sqlx4k: A small non-blocking database driver written in Kotlin for the Native platform.</a></p><p>All contributions are welcome. Thank you for now.</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://kotlinlang.org/>Kotlin Programming Language</a></li><li><a href=https://ktor.io/>Ktor: Build Asynchronous Servers and Clients in Kotlin | Ktor Framework</a></li><li><a href=https://github.com/launchbadge/sqlx>GitHub - launchbadge/sqlx: 🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, and SQLite.</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://smyrgeorge.github.io/tags/dev/>Dev</a></li><li><a href=https://smyrgeorge.github.io/tags/kotlin/>Kotlin</a></li><li><a href=https://smyrgeorge.github.io/tags/ffi/>Ffi</a></li><li><a href=https://smyrgeorge.github.io/tags/rust/>Rust</a></li><li><a href=https://smyrgeorge.github.io/tags/database-driver/>Database-Driver</a></li><li><a href=https://smyrgeorge.github.io/tags/postgres/>Postgres</a></li><li><a href=https://smyrgeorge.github.io/tags/mysql/>Mysql</a></li><li><a href=https://smyrgeorge.github.io/tags/sqlite/>Sqlite</a></li></ul></footer><hr style=margin-top:56px><div id=disqus_thread style=margin-top:20px></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://smyrgeorge.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://smyrgeorge.github.io/>:: exploration and stuff ::</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>