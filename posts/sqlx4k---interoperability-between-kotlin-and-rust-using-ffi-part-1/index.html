<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sqlx4k - Interoperability between Kotlin and Rust (using FFI) | :: exploration and stuff ::</title>
<meta name=keywords content="dev,kotlin,ffi,rust"><meta name=description content="Introduction Previously, in the Sqlx4k - Introduction to Kotlin Native and FFI (Part 2), the second part of this series, we attempted to provide an introduction to how C Interoperability functions in Kotlin, offering various examples from the GitHub - smyrgeorge/sqlx4k codebase.
Sqlx4k is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the sqlx driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI."><meta name=author content="Yorgos S."><link rel=canonical href=https://smyrgeorge.github.io/posts/sqlx4k---interoperability-between-kotlin-and-rust-using-ffi-part-1/><link crossorigin=anonymous href=/assets/css/stylesheet.c6c962257e0400eb9126b021c44264dc26b683382072bc5b0255db23207eaf8a.css integrity="sha256-xsliJX4EAOuRJrAhxEJk3Ca2gzggcrxbAlXbIyB+r4o=" rel="preload stylesheet" as=style><link rel=icon href=https://smyrgeorge.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://smyrgeorge.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://smyrgeorge.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://smyrgeorge.github.io/apple-touch-icon.png><link rel=mask-icon href=https://smyrgeorge.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://smyrgeorge.github.io/posts/sqlx4k---interoperability-between-kotlin-and-rust-using-ffi-part-1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-0Z3MG3WT5H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0Z3MG3WT5H")}</script><meta property="og:title" content="Sqlx4k - Interoperability between Kotlin and Rust (using FFI)"><meta property="og:description" content="Introduction Previously, in the Sqlx4k - Introduction to Kotlin Native and FFI (Part 2), the second part of this series, we attempted to provide an introduction to how C Interoperability functions in Kotlin, offering various examples from the GitHub - smyrgeorge/sqlx4k codebase.
Sqlx4k is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the sqlx driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI."><meta property="og:type" content="article"><meta property="og:url" content="https://smyrgeorge.github.io/posts/sqlx4k---interoperability-between-kotlin-and-rust-using-ffi-part-1/"><meta property="og:image" content="https://smyrgeorge.github.io/images/bfc5f1d0b3838151728b268ebedb1f89b234eea8.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-01T17:19:17+02:00"><meta property="article:modified_time" content="2024-08-01T17:19:17+02:00"><meta property="og:site_name" content=":: exploration and stuff ::"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://smyrgeorge.github.io/images/bfc5f1d0b3838151728b268ebedb1f89b234eea8.png"><meta name=twitter:title content="Sqlx4k - Interoperability between Kotlin and Rust (using FFI)"><meta name=twitter:description content="Introduction Previously, in the Sqlx4k - Introduction to Kotlin Native and FFI (Part 2), the second part of this series, we attempted to provide an introduction to how C Interoperability functions in Kotlin, offering various examples from the GitHub - smyrgeorge/sqlx4k codebase.
Sqlx4k is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the sqlx driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://smyrgeorge.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Sqlx4k - Interoperability between Kotlin and Rust (using FFI)","item":"https://smyrgeorge.github.io/posts/sqlx4k---interoperability-between-kotlin-and-rust-using-ffi-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sqlx4k - Interoperability between Kotlin and Rust (using FFI)","name":"Sqlx4k - Interoperability between Kotlin and Rust (using FFI)","description":"Introduction Previously, in the Sqlx4k - Introduction to Kotlin Native and FFI (Part 2), the second part of this series, we attempted to provide an introduction to how C Interoperability functions in Kotlin, offering various examples from the GitHub - smyrgeorge/sqlx4k codebase.\nSqlx4k is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the sqlx driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI.","keywords":["dev","kotlin","ffi","rust"],"articleBody":"Introduction Previously, in the Sqlx4k - Introduction to Kotlin Native and FFI (Part 2), the second part of this series, we attempted to provide an introduction to how C Interoperability functions in Kotlin, offering various examples from the GitHub - smyrgeorge/sqlx4k codebase.\nSqlx4k is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the sqlx driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI.\nIn this article, we are going to see in detail how it works and how we can benefit from the integration between the two.\nProject Setup First of all, let’s take a look at the file tree:\nThe Kotlin code is located under the src directory. The Rust code is located in the rust_lib directory. sqlx4k ├── build.gradle.kts ├── rust_lib │ ├── Cargo.lock │ ├── Cargo.toml │ ├── build.rs │ └── src │ └── lib.rs └── src ├── nativeInterop │ └── cinterop │ ├── aarch64-apple-darwin.def │ ├── aarch64-unknown-linux-gnu.def │ ├── x86_64-apple-darwin.def │ └── x86_64-unknown-linux-gnu.def └── nativeMain └── kotlin └── io └── github └── smyrgeorge └── sqlx4k ├── Driver.kt ├── Sqlx4k.kt ├── Transaction.kt └── impl ├── Postgres.kt └── extensions.kt For more details, you can always take a look at the project’s repository.\nRust Setup Now, let’s examine the Rust configuration. First, take a look at the Cargo.toml file:\n# We going to show only the important parts here. # You can see the full file in the project's repoisory. [lib] crate-type = [\"staticlib\"] [build-dependencies] # https://crates.io/crates/cbindgen cbindgen = \"0.26.0\" So, we can make the following observations:\ncrate-type must be staticlib. According to the documentation: *A static system library will be produced. This is different from other library outputs in that the compiler will never attempt to link to staticlib outputs. The purpose of this output type is to create a static library containing all of the local crate’s code along with all upstream dependencies. This output type will create .a files on Linux, macOS and Windows (MinGW), and .lib files on Windows (MSVC). This format is recommended for use in situations such as linking Rust code into an existing non-Rust application because it will not have dynamic dependencies on other Rust code. We need the build-dependency cbindgen. *Creates C/C++11 headers for Rust libraries which expose a public C API.* Kotlin Setup Now, let’s take a look at the build.gradle.kts file that configures the Kotlin part. We will focus on the most interesting sections.\nimport org.gradle.nativeplatform.platform.internal.DefaultNativePlatform import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget import java.lang.System.getenv plugins { kotlin(\"multiplatform\") } // Find the current OS and Architecture. private val os = DefaultNativePlatform.getCurrentOperatingSystem() private val arch = DefaultNativePlatform.getCurrentArchitecture() // Appends `.exe` if the build is running in wingows. private val exeExt: String get() = when { os.isWindows -\u003e \".exe\" else -\u003e \"\" } // Locate the cargo executable. private val cargo: String get() = when { os.isWindows -\u003e getenv(\"USERPROFILE\") else -\u003e getenv(\"HOME\") }?.let(::File) ?.resolve(\".cargo/bin/cargo$exeExt\") ?.takeIf { it.exists() } ?.absolutePath ?: throw GradleException( \"Rust cargo binary is required to build project.\") // Build targets val chosenTargets = (properties[\"targets\"] as? String)?.split(\",\") ?: listOf(\"macosArm64\", \"macosX64\", \"linuxArm64\", \"linuxX64\") kotlin { fun KotlinNativeTarget.rust(target: String) { compilations.getByName(\"main\").cinterops { create(\"librust_lib\") { // Create a gradle task for each of one of the build targets. val cargo = tasks.create(\"cargo-$target\") { exec { executable = cargo args( \"build\", \"--manifest-path\", projectDir .resolve(\"rust_lib/Cargo.toml\") .absolutePath, // Path to the `Cargo.toml` file. \"--package\", \"rust_lib\", \"--lib\", \"--target=$target\", // Define the Rust build target. \"--release\" ) } } // Build Rust code before call interop task. tasks.getByName(interopProcessingTaskName) { dependsOn(cargo) } // Set the .def file for each platform. // The .def file describes what will be included into bindings. definitionFile.set( projectDir .resolve(\"src/nativeInterop/cinterop/$target.def\") ) } } } // Setup the build targets. // For each platform we need to define the rust target build. val availableTargets = mapOf( Pair(\"macosArm64\") { macosArm64 { rust(\"aarch64-apple-darwin\") } }, Pair(\"macosX64\") { macosX64 { rust(\"x86_64-apple-darwin\") } }, Pair(\"linuxArm64\") { linuxArm64 { rust(\"aarch64-unknown-linux-gnu\") } }, Pair(\"linuxX64\") { linuxX64 { rust(\"x86_64-unknown-linux-gnu\") } }, ) // Invoke build for each one of the selected targets. chosenTargets.forEach { println(\"Enabling target $it\") availableTargets[it]?.invoke() } // Other configs, non-related to this article (depedencies etc.). applyDefaultHierarchyTemplate() sourceSets { configureEach { languageSettings.progressiveMode = true } val nativeMain by getting { dependencies { // https://github.com/Kotlin/kotlinx.coroutines implementation( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1\") } } } } .def files According to the Kotlin documentation, we need to create some .def files that define the bindings. In our case, for the aarch64-apple-darwin target, we have the following file:\npackage = librust_lib headers = rust_lib.h compilerOpts = -I./rust_lib/target staticLibraries = librust_lib.a libraryPaths = ./rust_lib/target/aarch64-apple-darwin/release Build If we build the project we should see something like:\n\u003e Configure project :sqlx4k Enabling target macosArm64 ... ... Finished `release` profile [optimized] target(s) in 7.17s Enabling target macosX64 ... ... Finished `release` profile [optimized] target(s) in 7.14s Enabling target linuxArm64 ... ... Finished `release` profile [optimized] target(s) in 7.17s Enabling target linuxX64 ... ... Finished `release` profile [optimized] target(s) in 7.14s ... BUILD SUCCESSFUL in 24s 35 actionable tasks: 3 executed, 32 up-to-date As we can see, gradle first triggers the build of the Rust code for each of the selected targets (in our case, macosArm64, macosX64, linuxArm64, linuxX64) and then builds the Kotlin code (located under the src folder).\nGenerated Rust Files The Rust build generates a couple of files that are then used by the Kotlin compiler.\nrust_lib/target/rust_lib.h: The generated (by cbindgen, that we saw earlier) C bindings (header files)\n// Only a small part of the original file is shown here. #include #include #include #include #define OK -1 #define ERROR_DATABASE 0 typedef struct Sqlx4kColumn { int ordinal; char *name; int kind; int size; void *value; } Sqlx4kColumn; void sqlx4k_query(const char *sql, void *callback, void (*fun)(struct Ptr, struct Sqlx4kResult*)); void sqlx4k_fetch_all(const char *sql, void *callback, void (*fun)(struct Ptr, struct Sqlx4kResult*)); void sqlx4k_free_result(struct Sqlx4kResult *ptr); rust_lib/target/aarch64-apple-darwin/release/librust_lib.a: The native binary that will be linked to our code. Of course, we should find the corresponding .a files for each platform for which we enabled the build.\nLet’s see a code example in action Assuming that you have the following Rust function:\n#[no_mangle] pub extern \"C\" fn sqlx4k_pool_size() -\u003e c_int { unsafe { SQLX4K.get().unwrap() }.pool.size() as c_int } Then, you can call the above Rust function from the Kotlin as follows:\nimport librust_lib.sqlx4k_pool_size fun poolSize(): Int = sqlx4k_pool_size() In this article we don’t going to explain how FFI works at the Rust part. You can easily review the available documentation. Also feel free to look at the references section below. You can find several other examples in the project’s codebase.\nConclusion As we can see, it is actually very easy to “integrate” Kotlin with Rust.\nAt this moment, with the Kotlin ecosystem still in a very young stage, we can benefit by bringing well-tested libraries and functionality to the ecosystem.\nIn the next part of this series, we will see in detail how we can utilise the async features that both languages offer in order to create non-blocking IO code. Until then, you can review the previous articles here: :: exploration and stuff :: and also check out my GitHub repository: smyrgeorge (Yorgos S.) · GitHub.\nReferences cbindgen - crates.io: Rust Package Registry Interoperability with C | Kotlin Documentation Linkage - The Rust Reference FFI - The Rustonomicon ","wordCount":"1208","inLanguage":"en","image":"https://smyrgeorge.github.io/images/bfc5f1d0b3838151728b268ebedb1f89b234eea8.png","datePublished":"2024-08-01T17:19:17+02:00","dateModified":"2024-08-01T17:19:17+02:00","author":{"@type":"Person","name":"Yorgos S."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://smyrgeorge.github.io/posts/sqlx4k---interoperability-between-kotlin-and-rust-using-ffi-part-1/"},"publisher":{"@type":"Organization","name":":: exploration and stuff ::","logo":{"@type":"ImageObject","url":"https://smyrgeorge.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://smyrgeorge.github.io/ accesskey=h title=":: exploration and stuff :: (Alt + H)"><img src=https://smyrgeorge.github.io/apple-touch-icon.png alt aria-label=logo height=35>:: exploration and stuff ::</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://smyrgeorge.github.io/archives title=archive><span>archive</span></a></li><li><a href=https://smyrgeorge.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://smyrgeorge.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://smyrgeorge.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://smyrgeorge.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://smyrgeorge.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Sqlx4k - Interoperability between Kotlin and Rust (using FFI)</h1><div class=post-meta><span title='2024-08-01 17:19:17 +0200 CEST'>August 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1208 words&nbsp;·&nbsp;Yorgos S.&nbsp;|&nbsp;<a href=https://github.com/smyrgeorge/smyrgeorge.github.io-code/blob/main/content/posts/Sqlx4k%20-%20Interoperability%20between%20Kotlin%20and%20Rust,%20using%20FFI%20%28Part%201%29.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://smyrgeorge.github.io/images/bfc5f1d0b3838151728b268ebedb1f89b234eea8.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#project-setup>Project Setup</a><ul><li><a href=#rust-setup>Rust Setup</a></li><li><a href=#kotlin-setup>Kotlin Setup</a></li></ul></li><li><a href=#build>Build</a><ul><li><a href=#generated-rust-files>Generated Rust Files</a></li></ul></li><li><a href=#lets-see-a-code-example-in-action>Let&rsquo;s see a code example in action</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Previously, in the <a href=https://smyrgeorge.github.io/posts/sqlx4k---introduction-to-the-kotlin-native-and-ffi-part-2/>Sqlx4k - Introduction to Kotlin Native and FFI (Part 2)</a>, the second part of this series, we attempted to provide an introduction to how <code>C Interoperability</code> functions in Kotlin, offering various examples from the <a href=https://github.com/smyrgeorge/sqlx4k>GitHub - smyrgeorge/sqlx4k</a> codebase.</p><p><code>Sqlx4k</code> is a small, non-blocking PostgreSQL database driver written in Kotlin for the Native platform. It wraps the <code>sqlx</code> driver from the Rust ecosystem under the hood. The communication between the two languages is facilitated using FFI.</p><p>In this article, we are going to see in detail how it works and how we can benefit from the integration between the two.</p><p><img loading=lazy src=/images/bfc5f1d0b3838151728b268ebedb1f89b234eea8.png alt=sqlx4k></p><h2 id=project-setup>Project Setup<a hidden class=anchor aria-hidden=true href=#project-setup>#</a></h2><p>First of all, let&rsquo;s take a look at the file tree:</p><ul><li>The Kotlin code is located under the <code>src</code> directory.</li><li>The Rust code is located in the <code>rust_lib</code> directory.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>sqlx4k
</span></span><span class=line><span class=cl>├── build.gradle.kts
</span></span><span class=line><span class=cl>├── rust_lib
</span></span><span class=line><span class=cl>│   ├── Cargo.lock
</span></span><span class=line><span class=cl>│   ├── Cargo.toml
</span></span><span class=line><span class=cl>│   ├── build.rs
</span></span><span class=line><span class=cl>│   └── src
</span></span><span class=line><span class=cl>│       └── lib.rs
</span></span><span class=line><span class=cl>└── src
</span></span><span class=line><span class=cl>    ├── nativeInterop
</span></span><span class=line><span class=cl>    │   └── cinterop
</span></span><span class=line><span class=cl>    │       ├── aarch64-apple-darwin.def
</span></span><span class=line><span class=cl>    │       ├── aarch64-unknown-linux-gnu.def
</span></span><span class=line><span class=cl>    │       ├── x86_64-apple-darwin.def
</span></span><span class=line><span class=cl>    │       └── x86_64-unknown-linux-gnu.def
</span></span><span class=line><span class=cl>    └── nativeMain
</span></span><span class=line><span class=cl>        └── kotlin
</span></span><span class=line><span class=cl>            └── io
</span></span><span class=line><span class=cl>                └── github
</span></span><span class=line><span class=cl>                    └── smyrgeorge
</span></span><span class=line><span class=cl>                        └── sqlx4k
</span></span><span class=line><span class=cl>                            ├── Driver.kt
</span></span><span class=line><span class=cl>                            ├── Sqlx4k.kt
</span></span><span class=line><span class=cl>                            ├── Transaction.kt
</span></span><span class=line><span class=cl>                            └── impl
</span></span><span class=line><span class=cl>                                ├── Postgres.kt
</span></span><span class=line><span class=cl>                                └── extensions.kt
</span></span></code></pre></div><p>For more details, you can always take a look at the project&rsquo;s repository.</p><h3 id=rust-setup>Rust Setup<a hidden class=anchor aria-hidden=true href=#rust-setup>#</a></h3><p>Now, let&rsquo;s examine the Rust configuration. First, take a look at the <code>Cargo.toml</code> file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># We going to show only the important parts here.</span>
</span></span><span class=line><span class=cl><span class=c># You can see the full file in the project&#39;s repoisory.</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>lib</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>crate-type</span> <span class=p>=</span> <span class=p>[</span><span class=s2>&#34;staticlib&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>build-dependencies</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c># https://crates.io/crates/cbindgen</span>
</span></span><span class=line><span class=cl><span class=nx>cbindgen</span> <span class=p>=</span> <span class=s2>&#34;0.26.0&#34;</span>
</span></span></code></pre></div><p>So, we can make the following observations:</p><ul><li><code>crate-type</code> must be <code>staticlib</code>. According to the documentation: *A static system library will be produced. This is different from other library outputs in that the compiler will never attempt to link to staticlib outputs. The purpose of this output type is to create a static library containing all of the local crate&rsquo;s code along with all upstream dependencies. This output type will create .a files on Linux, macOS and Windows (MinGW), and <em>.lib files on Windows (MSVC). This format is recommended for use in situations such as linking Rust code into an existing non-Rust application because it will not have dynamic dependencies on other Rust code.</em></li><li>We need the build-dependency <code>cbindgen</code>. *Creates C/C++11 headers for Rust libraries which expose a public C API.*</li></ul><h3 id=kotlin-setup>Kotlin Setup<a hidden class=anchor aria-hidden=true href=#kotlin-setup>#</a></h3><p>Now, let&rsquo;s take a look at the <code>build.gradle.kts</code> file that configures the Kotlin part. We will focus on the most interesting sections.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>import</span> <span class=nn>org.gradle.nativeplatform.platform.internal.DefaultNativePlatform</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>java.lang.System.getenv</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>plugins</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>kotlin</span><span class=p>(</span><span class=s2>&#34;multiplatform&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Find the current OS and Architecture.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span> <span class=k>val</span> <span class=py>os</span> <span class=p>=</span> <span class=nc>DefaultNativePlatform</span><span class=p>.</span><span class=n>getCurrentOperatingSystem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>val</span> <span class=py>arch</span> <span class=p>=</span> <span class=nc>DefaultNativePlatform</span><span class=p>.</span><span class=n>getCurrentArchitecture</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Appends `.exe` if the build is running in wingows.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span> <span class=k>val</span> <span class=py>exeExt</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>when</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>os</span><span class=p>.</span><span class=n>isWindows</span> <span class=o>-&gt;</span> <span class=s2>&#34;.exe&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>-&gt;</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Locate the cargo executable.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span> <span class=k>val</span> <span class=py>cargo</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>when</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>os</span><span class=p>.</span><span class=n>isWindows</span> <span class=o>-&gt;</span> <span class=n>getenv</span><span class=p>(</span><span class=s2>&#34;USERPROFILE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>-&gt;</span> <span class=n>getenv</span><span class=p>(</span><span class=s2>&#34;HOME&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=o>?.</span><span class=n>let</span><span class=p>(</span><span class=o>::</span><span class=n>File</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>?.</span><span class=n>resolve</span><span class=p>(</span><span class=s2>&#34;.cargo/bin/cargo</span><span class=si>$exeExt</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>?.</span><span class=n>takeIf</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>exists</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>?.</span><span class=n>absolutePath</span>
</span></span><span class=line><span class=cl>        <span class=o>?:</span> <span class=k>throw</span> <span class=n>GradleException</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;Rust cargo binary is required to build project.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Build targets
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>chosenTargets</span> <span class=p>=</span> <span class=p>(</span><span class=n>properties</span><span class=p>[</span><span class=s2>&#34;targets&#34;</span><span class=p>]</span> <span class=k>as</span><span class=p>?</span> <span class=n>String</span><span class=p>)</span><span class=o>?.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;,&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>?:</span> <span class=n>listOf</span><span class=p>(</span><span class=s2>&#34;macosArm64&#34;</span><span class=p>,</span> <span class=s2>&#34;macosX64&#34;</span><span class=p>,</span> <span class=s2>&#34;linuxArm64&#34;</span><span class=p>,</span> <span class=s2>&#34;linuxX64&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>kotlin</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>KotlinNativeTarget</span><span class=p>.</span><span class=n>rust</span><span class=p>(</span><span class=n>target</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>compilations</span><span class=p>.</span><span class=n>getByName</span><span class=p>(</span><span class=s2>&#34;main&#34;</span><span class=p>).</span><span class=n>cinterops</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>create</span><span class=p>(</span><span class=s2>&#34;librust_lib&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Create a gradle task for each of one of the build targets.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>val</span> <span class=py>cargo</span> <span class=p>=</span> <span class=n>tasks</span><span class=p>.</span><span class=n>create</span><span class=p>(</span><span class=s2>&#34;cargo-</span><span class=si>$target</span><span class=s2>&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>exec</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>executable</span> <span class=p>=</span> <span class=n>cargo</span>
</span></span><span class=line><span class=cl>                        <span class=n>args</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                            <span class=s2>&#34;build&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=s2>&#34;--manifest-path&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=n>projectDir</span>
</span></span><span class=line><span class=cl>                                <span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=s2>&#34;rust_lib/Cargo.toml&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=p>.</span><span class=n>absolutePath</span><span class=p>,</span> <span class=c1>// Path to the `Cargo.toml` file.
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=s2>&#34;--package&#34;</span><span class=p>,</span> <span class=s2>&#34;rust_lib&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=s2>&#34;--lib&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=s2>&#34;--target=</span><span class=si>$target</span><span class=s2>&#34;</span><span class=p>,</span> <span class=c1>// Define the Rust build target.
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=s2>&#34;--release&#34;</span>
</span></span><span class=line><span class=cl>                        <span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// Build Rust code before call interop task.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>tasks</span><span class=p>.</span><span class=n>getByName</span><span class=p>(</span><span class=n>interopProcessingTaskName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>dependsOn</span><span class=p>(</span><span class=n>cargo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// Set the .def file for each platform.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// The .def file describes what will be included into bindings.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>definitionFile</span><span class=p>.</span><span class=k>set</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=n>projectDir</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=s2>&#34;src/nativeInterop/cinterop/</span><span class=si>$target</span><span class=s2>.def&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Setup the build targets.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// For each platform we need to define the rust target build.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>availableTargets</span> <span class=p>=</span> <span class=n>mapOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>Pair</span><span class=p>(</span><span class=s2>&#34;macosArm64&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>macosArm64</span> <span class=p>{</span> <span class=n>rust</span><span class=p>(</span><span class=s2>&#34;aarch64-apple-darwin&#34;</span><span class=p>)</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=n>Pair</span><span class=p>(</span><span class=s2>&#34;macosX64&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>macosX64</span> <span class=p>{</span> <span class=n>rust</span><span class=p>(</span><span class=s2>&#34;x86_64-apple-darwin&#34;</span><span class=p>)</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=n>Pair</span><span class=p>(</span><span class=s2>&#34;linuxArm64&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>linuxArm64</span> <span class=p>{</span> <span class=n>rust</span><span class=p>(</span><span class=s2>&#34;aarch64-unknown-linux-gnu&#34;</span><span class=p>)</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=n>Pair</span><span class=p>(</span><span class=s2>&#34;linuxX64&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>linuxX64</span> <span class=p>{</span> <span class=n>rust</span><span class=p>(</span><span class=s2>&#34;x86_64-unknown-linux-gnu&#34;</span><span class=p>)</span> <span class=p>}</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Invoke build for each one of the selected targets.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>chosenTargets</span><span class=p>.</span><span class=n>forEach</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Enabling target </span><span class=si>$it</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>availableTargets</span><span class=p>[</span><span class=k>it</span><span class=p>]</span><span class=o>?.</span><span class=n>invoke</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Other configs, non-related to this article (depedencies etc.).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>applyDefaultHierarchyTemplate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>sourceSets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>configureEach</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>languageSettings</span><span class=p>.</span><span class=n>progressiveMode</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>nativeMain</span> <span class=k>by</span> <span class=n>getting</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dependencies</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// https://github.com/Kotlin/kotlinx.coroutines
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>implementation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=def-files>.def files<a hidden class=anchor aria-hidden=true href=#def-files>#</a></h4><p>According to the Kotlin documentation, we need to create some <code>.def</code> files that define the bindings. In our case, for the <code>aarch64-apple-darwin</code> target, we have the following file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>package = librust_lib
</span></span><span class=line><span class=cl>headers = rust_lib.h
</span></span><span class=line><span class=cl>compilerOpts = -I./rust_lib/target
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>staticLibraries = librust_lib.a
</span></span><span class=line><span class=cl>libraryPaths = ./rust_lib/target/aarch64-apple-darwin/release
</span></span></code></pre></div><h2 id=build>Build<a hidden class=anchor aria-hidden=true href=#build>#</a></h2><p>If we build the project we should see something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>&gt; Configure project :sqlx4k
</span></span><span class=line><span class=cl>Enabling target macosArm64
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Finished `release` profile [optimized] target(s) in 7.17s
</span></span><span class=line><span class=cl>Enabling target macosX64
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Finished `release` profile [optimized] target(s) in 7.14s
</span></span><span class=line><span class=cl>Enabling target linuxArm64
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Finished `release` profile [optimized] target(s) in 7.17s
</span></span><span class=line><span class=cl>Enabling target linuxX64
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    Finished `release` profile [optimized] target(s) in 7.14s
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>BUILD SUCCESSFUL in 24s
</span></span><span class=line><span class=cl>35 actionable tasks: 3 executed, 32 up-to-date
</span></span></code></pre></div><p>As we can see, <code>gradle</code> first triggers the build of the Rust code for each of the selected targets (in our case, <code>macosArm64</code>, <code>macosX64</code>, <code>linuxArm64</code>, <code>linuxX64</code>) and then builds the Kotlin code (located under the <code>src</code> folder).</p><h3 id=generated-rust-files>Generated Rust Files<a hidden class=anchor aria-hidden=true href=#generated-rust-files>#</a></h3><p>The Rust build generates a couple of files that are then used by the Kotlin compiler.</p><p><code>rust_lib/target/rust_lib.h</code>:
The generated (by <code>cbindgen</code>, that we saw earlier) C bindings (header files)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Only a small part of the original file is shown here.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdarg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdbool.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define OK -1
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define ERROR_DATABASE 0
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Sqlx4kColumn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ordinal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>kind</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Sqlx4kColumn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sqlx4k_query</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>sql</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>callback</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fun</span><span class=p>)(</span><span class=k>struct</span> <span class=n>Ptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Sqlx4kResult</span><span class=o>*</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sqlx4k_fetch_all</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>sql</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=kt>void</span> <span class=o>*</span><span class=n>callback</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>fun</span><span class=p>)(</span><span class=k>struct</span> <span class=n>Ptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Sqlx4kResult</span><span class=o>*</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sqlx4k_free_result</span><span class=p>(</span><span class=k>struct</span> <span class=n>Sqlx4kResult</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span></code></pre></div><p><code>rust_lib/target/aarch64-apple-darwin/release/librust_lib.a</code>:
The native binary that will be linked to our code. Of course, we should find the corresponding <code>.a</code> files for each platform for which we enabled the build.</p><h2 id=lets-see-a-code-example-in-action>Let&rsquo;s see a code example in action<a hidden class=anchor aria-hidden=true href=#lets-see-a-code-example-in-action>#</a></h2><p>Assuming that you have the following Rust function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[no_mangle]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>extern</span><span class=w> </span><span class=s>&#34;C&#34;</span><span class=w> </span><span class=k>fn</span> <span class=nf>sqlx4k_pool_size</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>c_int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=no>SQLX4K</span><span class=p>.</span><span class=n>get</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=w> </span><span class=p>}.</span><span class=n>pool</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>c_int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Then, you can call the above Rust function from the Kotlin as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>import</span> <span class=nn>librust_lib.sqlx4k_pool_size</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>poolSize</span><span class=p>():</span> <span class=n>Int</span> <span class=p>=</span> <span class=n>sqlx4k_pool_size</span><span class=p>()</span>
</span></span></code></pre></div><p>In this article we don&rsquo;t going to explain how FFI works at the Rust part. You can easily review the available documentation. Also feel free to look at the references section below. You can find several other examples in the project&rsquo;s codebase.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>As we can see, it is actually very easy to &ldquo;integrate&rdquo; Kotlin with Rust.</p><p>At this moment, with the Kotlin ecosystem still in a very young stage, we can benefit by bringing well-tested libraries and functionality to the ecosystem.</p><p>In the next part of this series, we will see in detail how we can utilise the <code>async</code> features that both languages offer in order to create non-blocking IO code. Until then, you can review the previous articles here: <a href=https://smyrgeorge.github.io/>:: exploration and stuff ::</a> and also check out my GitHub repository: <a href=https://github.com/smyrgeorge>smyrgeorge (Yorgos S.) · GitHub</a>.</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://crates.io/crates/cbindgen>cbindgen - crates.io: Rust Package Registry</a></li><li><a href=https://kotlinlang.org/docs/native-c-interop.html>Interoperability with C | Kotlin Documentation</a></li><li><a href=https://doc.rust-lang.org/reference/linkage.html>Linkage - The Rust Reference</a></li><li><a href=https://doc.rust-lang.org/nomicon/ffi.html>FFI - The Rustonomicon</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://smyrgeorge.github.io/tags/dev/>Dev</a></li><li><a href=https://smyrgeorge.github.io/tags/kotlin/>Kotlin</a></li><li><a href=https://smyrgeorge.github.io/tags/ffi/>Ffi</a></li><li><a href=https://smyrgeorge.github.io/tags/rust/>Rust</a></li></ul></footer><hr style=margin-top:56px><div id=disqus_thread style=margin-top:20px></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://smyrgeorge.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2024 <a href=https://smyrgeorge.github.io/>:: exploration and stuff ::</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>